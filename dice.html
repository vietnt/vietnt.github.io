<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Three.js Dice</title>
</head>
<body>
<script>
// Load Three.js and its examples via CDN
const script = document.createElement('script');
script.src = 'https://cdn.jsdelivr.net/npm/three@latest/build/three.min.js';
document.head.appendChild(script);

script.onload = () => {
  const orbitScript = document.createElement('script');
  orbitScript.src = 'https://cdn.jsdelivr.net/npm/three@latest/examples/js/controls/OrbitControls.js';
  document.head.appendChild(orbitScript);

  orbitScript.onload = () => {
    const roundedBoxScript = document.createElement('script');
    roundedBoxScript.src = 'https://cdn.jsdelivr.net/npm/three@latest/examples/js/geometries/RoundedBoxGeometry.js';
    document.head.appendChild(roundedBoxScript);

    roundedBoxScript.onload = () => {
      // Scene, camera, and renderer setup
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xeeeeee);

      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(2, 2, 4);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
      directionalLight.position.set(5, 5, 5);
      scene.add(directionalLight);

      // Create the dice with rounded corners
      const diceGeometry = new THREE.RoundedBoxGeometry(1, 1, 1, 10, 0.2);
      const diceMaterial = new THREE.MeshStandardMaterial({
        color: 0xff0000, 
        roughness: 0.1,
        metalness: 0.1
      });
      const dice = new THREE.Mesh(diceGeometry, diceMaterial);
      scene.add(dice);

      // Function to add dots to the dice
      function addDiceDots(facePositions) {
        const dotMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.01, metalness: 0.1 });
        


        facePositions.forEach((face) => {
            const dotGeometry = new THREE.SphereGeometry(0.08, 16, 16);
            const n = face.length;
            if (n == 3 || n == 4) {
                dotGeometry.scale(1.0, 0.5, 1.0);
            }
            if (n == 5 || n == 2) {
                dotGeometry.scale(0.5, 1.0, 1.0);
            }

            if (n == 6) {
                dotGeometry.scale(1.0, 1.0, 0.5);
            }
            if (n == 1) {
                dotGeometry.scale(2.0, 2.0, 0.5);
            }

          face.forEach((position) => {
            const dot = new THREE.Mesh(dotGeometry, dotMaterial);
            const p = position.map(p => p * 0.95);
            dot.position.set(p[0], p[1], p[2]);
            dice.add(dot);
          });
        });
      }

      // New dot positions so each face is on a unique side:
      //   Face 1 -> +Z
      //   Face 2 -> +X
      //   Face 3 -> +Y
      //   Face 4 -> –Y
      //   Face 5 -> –X
      //   Face 6 -> –Z
      const diceDots = [
        // Face 1 (one pip, z = +0.52)
        [[ 0,    0,    0.52 ]],

        // Face 2 (two pips, x = +0.52)
        [[ 0.52,  0.2,  0.2 ],
         [ 0.52, -0.2, -0.2 ]],

        // Face 3 (three pips, y = +0.52)
        [[-0.2,  0.52,  0.2 ],
         [ 0,    0.52,  0   ],
         [ 0.2,  0.52, -0.2 ]],

        // Face 4 (four pips, y = –0.52)
        [[-0.2, -0.52,  0.2 ],
         [-0.2, -0.52, -0.2 ],
         [ 0.2, -0.52,  0.2 ],
         [ 0.2, -0.52, -0.2 ]],

        // Face 5 (five pips, x = –0.52)
        [[-0.52,  0.3,   0.3 ],
         [-0.52,  0.3,  -0.3 ],
         [-0.52, -0.3,   0.3 ],
         [-0.52, -0.3,  -0.3 ],
         [-0.52,  0,     0   ]],

        // Face 6 (six pips, z = –0.52)
        [[-0.2,  0.3,  -0.52 ],
         [-0.2,  0,    -0.52 ],
         [-0.2, -0.3,  -0.52 ],
         [ 0.2,  0.3,  -0.52 ],
         [ 0.2,  0,    -0.52 ],
         [ 0.2, -0.3,  -0.52 ]]
      ];

      addDiceDots(diceDots);

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
        dice.rotation.x += 0.06;
        dice.rotation.y += 0.02;
        dice.rotation.z += 0.04;
      }

      animate();

      // Resize handler
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);        
      });
    };
  };
};
</script>
</body>
</html>
